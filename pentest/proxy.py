from mitmproxy import proxy, options
from mitmproxy.tools.dump import DumpMaster
from mitmproxy.http import HTTPFlow
from mitmproxy.proxy.config import ProxyConfig
from mitmproxy.proxy.server import ProxyServer

from .models import proxy_data
from lib.config_json import load_config
import threading
import asyncio
import os

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))




PROXY_LISTEN_PORT = load_config('PROXY_LISTEN_PORT')
PROXY_LISTEN_HOST = load_config('PROXY_LISTEN_HOST')
EXCLUDE_STATIC_FILE = load_config('EXCLUDE_STATIC_FILE')

class Capture:
    def request(self,  flow: HTTPFlow):
        pass

    def response(self,  flow: HTTPFlow):
        path = '/{}'.format('/'.join(flow.request.path_components))

        try:
            client_ip = flow.client_conn.ip_address[0]
        except:
            client_ip = '0.0.0.0'
        # code = 0
        # for i in EXCLUDE_STATIC_FILE:  # Exclude static file in capture packet
        #     if path.find(i) > 0:
        #         code = 1
        #         break
        # if code == 0:
        headers = ""
        cookies = ""
        for i in flow.request.headers:
            headers = headers + i + ":" + flow.request.headers[i] + "\n"
        for i in flow.request.cookies:
            cookies = cookies + i + "=" + flow.request.cookies[i] + ";"
        proxy_data.objects.create(
            host=flow.request.host + ":" + str(flow.request.port),
            domain="{}://{}".format(flow.request.scheme,flow.request.host + ":" + str(flow.request.port)),
            method=flow.request.method,
            url=flow.request.url,
            scheme=flow.request.scheme,
            request_headers=headers,
            request_content=str(flow.request.content, encoding="utf8"),
            path=path,
            status_code=flow.response.status_code,
            response_headers=flow.response.headers,
            response_content=flow.response.content,
            request_cookies=cookies,
            http_version=flow.request.http_version,
            ip=client_ip,
            data_packet= flow.request.method + ' ' + flow.request.url + ' ' + flow.request.http_version + '\n' + headers + '\n\n' + str(flow.request.content, encoding="utf8")
        )

def start_proxy():
    opts = options.Options(listen_host=PROXY_LISTEN_HOST, listen_port=PROXY_LISTEN_PORT, confdir=os.path.join(BASE_DIR,"ssl"), ssl_insecure=True)
    opts.add_option("body_size_limit", int, 0, "")
    pconf = ProxyConfig(opts)

    #There is no current event loop in thread 'Thread-1'错误
    #解决方法：到mitmproxy的master.py修改Master类的init函数，
    # loop = asyncio.new_event_loop()
    # asyncio.set_event_loop(loop)
    # self.should_exit = threading.Event()
    # self.channel = controller.Channel(
    #     self,
    #     loop,
    #     self.should_exit,
    # )
    try:
        m = DumpMaster(opts, with_termlog=False, with_dumper=False)
        m.server = ProxyServer(pconf)
        m.addons.add(Capture())
        print("监听地址：{}，监听端口：{}".format(PROXY_LISTEN_HOST,PROXY_LISTEN_PORT))
        m.run()
    except:
        pass



def shutdown_proxy():
    opts = options.Options(listen_host=PROXY_LISTEN_HOST, listen_port=PROXY_LISTEN_PORT, confdir=BASE_DIR + "/ssl/",
                           ssl_insecure=True)
    opts.add_option("body_size_limit", int, 0, "")
    pconf = ProxyConfig(opts)

    m = DumpMaster(opts, with_termlog=False, with_dumper=False)
    m.server = ProxyServer(pconf)
    m.addons.add(Capture())
    m.shutdown()
